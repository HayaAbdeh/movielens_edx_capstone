---
title: "movielens_report"
author: "HayaAbdeh"
date: "2021 june 26"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

Data science is the gate to introduce machine learning as a technique to describe big data and extract knowledge by applying algorithms that analyze and process data into helpful information and naturally intuitive solutions.  and as machine learning improves the modern business making in recent years, we can see Netflix one of the biggest companies that took an active role as producer and distributor for both film and television series, worked on improving a recommendation system to attract more subscription users.
We are going to mimic a predict movie rating system for users in a large movie dataset, which would be a challenge to find out the movies with a high rate since users prefer movies over others.
This is a four parts report, which had present the subject and the problem in its first part (the introduction). Also, will presents the ideas of the solutions in its second part (Summary), the third part reviews the algorithmsâ€™ model and the plots in the (Methods and modeling), the final part will show the results and conclusions.


## Summary 
The working mechanism is to apply the principles of machine learning to reduce the root mean squared error RMSE of the predicted ratings versus the actual ratings. This approach called matrix factorization. 
We are going to partition the data into train data and test data as a validation set, we are going to start with calculating RMSE with user bias since users prefer movies over others, then we are going to improve the RMSE within the next steps.
The dataset used is [MovieLens 10M dataset] (https://grouplens.org/datasets/movielens/10m/)
(http://files.grouplens.org/datasets/movielens/ml-10m.zip)




```{r cars}
library(tidyverse)
library(caret)
library(data.table)
 
# MovieLens 10M dataset:
# https://grouplens.org/datasets/movielens/10m/
# http://files.grouplens.org/datasets/movielens/ml-10m.zip

dl <- tempfile()
download.file("http://files.grouplens.org/datasets/movielens/ml-10m.zip", dl)


ratings <- fread(text = gsub("::", "\t", readLines(unzip(dl, "ml-10M100K/ratings.dat"))),
                 col.names = c("userId", "movieId", "rating", "timestamp"))

movies <- str_split_fixed(readLines(unzip(dl, "ml-10M100K/movies.dat")), "\\::", 3)
colnames(movies) <- c("movieId", "title", "genres")

# if using R 4.0 or later:
movies <- as.data.frame(movies) %>% mutate(movieId = as.numeric(movieId),
                                            title = as.character(title),
                                            genres = as.character(genres))
movielens <- left_join(ratings, movies, by = "movieId")

# Validation set will be 10% of MovieLens data
set.seed(1, sample.kind="Rounding") # if using R 3.5 or earlier, use `set.seed(1)`
test_index <- createDataPartition(y = movielens$rating, times = 1, p = 0.1, list = FALSE)
edx <- movielens[-test_index,]
temp <- movielens[test_index,]
# Make sure userId and movieId in validation set are also in edx set
validation <- temp %>% 
      semi_join(edx, by = "movieId") %>%
      semi_join(edx, by = "userId")

# Add rows removed from validation set back into edx set
removed <- anti_join(temp, validation)
edx <- rbind(edx, removed)

rm(dl, ratings, movies, test_index, temp, movielens, removed)


#head of the data set edx
head(edx)


# Most rated films
edx %>% group_by(title) %>%
  summarize(n_ratings = n()) %>%
  arrange(desc(n_ratings))

# Number of movies rated once
edx %>% group_by(title) %>%
  summarize(n_ratings = n()) %>%
  filter(n_ratings==1) %>%
  count() %>% pull()

#number of users in edx dataset
edx %>% group_by(userId) %>% summarize(count = n())


#number of movie ratings in some genres in the edx dataset

edx %>% filter(genres %like% "Drama") %>% summarize(n())
edx %>% filter(genres %like% "Comedy") %>% summarize(n())
edx %>% filter(genres %like% "Thriller") %>% summarize(n())
edx %>% filter(genres %like% "Romance") %>% summarize(n())

```
## Methods
# First we build a Naive model and calculate the average of edx  

```{r model, echo=TRUE}
mu <- mean(edx$rating)
RMSE(validation$rating, mu)

# We make a data frame to save the results of RMSE
results <- data.frame(model="Mean Of edx Model", RMSE=rmse)

#We can see that RMSE on the validation dataset is 1.06. It is very high and we need to get RMSE (below 0.87) so we should to improve the model.
```



#Add the movie bias term which calculate the average of the rankings for movies, we can use this formula:
$$Y_{u,i} = \hat{\mu} + b_i + \epsilon_{u,i}$$
# we calculated mu_hat as mu at the previous step

```{r model, echo=TRUE}
mu <- mean(edx$rating)
movie_bias <- edx %>%
group_by(movieId) %>%
summarize(movie_bias = mean(rating - mu))


```
# predict ratings with mu 
```{r model, echo=TRUE}
  predict_rat <- validation %>% 
  left_join(movie_bias, by='movieId') %>%
  mutate(pred = mu + movie_bias) %>%
  pull(pred)

RMSE(validation$rating, predict_rat)
rmse_result <- RMSE(validation$rating, predict_rat)

#Adding the result we had to the results dataset that we build before
results <- results %>% add_row(model="Movie Bias Model", RMSE=rmse_result)

# we notice that RMSE is 0.94 ,, still not got what we need

```

#Now calculate user bias term. to minimizes the effect of extreme ratings made by users and we will use the formula
$$Y_{u,i} = \hat{\mu} + b_i + b_u + \epsilon_{u,i}$$

```{r user bias, echo=TRUE}
# user bias  
# again the average of all movies 
# and use the movie_bias from the previous step
mu <- mean(edx$rating)
user_bias <- edx %>% 
left_join(movie_bias, by='movieId') %>%
group_by(userId) %>%
summarize(user_bias = mean(rating - mu - movie_bias))


```

# predict ratings with movie and user bias
```{r model, echo=TRUE}
mu <- mean(edx$rating)
predict_rat_user <- validation %>% 
left_join(movie_bias, by='movieId') %>%
left_join(user_bias, by='userId') %>%
mutate(pred = mu + movie_bias + user_bias) %>%
pull(pred)

RMSE(predict_rat_user, validation$rating)

# Let us Add the result to the results dataset
result_user <- RMSE(predict_rat_user, validation$rating)
results <- results %>% add_row(model="bias Movie and User  Model", RMSE= result_user)

# We got a RMSE = 0.8653488 this is a good result so far, letus continue to see if we can get better results.

```

# Calculating the rating as the Genres of the movies ,,, we use this formula 
$$Y_{u,i} = \hat{\mu} + b_i + b_u + b_{u,g} + \epsilon_{u,i}$$
```{r model, echo=TRUE}

mu <- mean(edx$rating)
# Calculate average by The movie
movie_avg <- edx %>%
   group_by(movieId) %>%
   summarize(movie_bias = mean(rating - mu))

# Calculate average by The user
user_avg <- edx %>%
   left_join(movie_avg, by='movieId') %>%
   group_by(userId) %>%
   summarize(user_bias = mean(rating - mu - movie_bias))

#Calculate the genres as the user prefer more
  prefered_genre <- edx %>%
  left_join(movie_avg, by='movieId') %>%
  left_join(user_avg, by='userId') %>%
  group_by(genres) %>%
  summarize(movie_user_genre = mean(rating - mu - movie_bias - user_bias))

# Compute the predicted ratings on validation dataset

rmse_m_u_g <- validation %>%
   left_join(movie_avg, by='movieId') %>%
   left_join(user_avg, by='userId') %>%
   left_join(prefered_genre, by='genres') %>%
   mutate(pred = mu + movie_bias + user_bias + movie_user_genre) %>%
   pull(pred)

RMSE(validation$rating, rmse_m_u_g)

result_m_u_g <- RMSE(validation$rating, rmse_m_u_g)

#  Add the result to the results dataset

results <- results %>% add_row(model="Movie and User and genres Model", RMSE= result_m_u_g)

# We got a RMSE = 0.8649469 this is a very satisfying result but it did not make a very significant improvement since the RMES value is close to the previous model,, 

```

## Regularization approch 
#57.	Regularization permits us to penalize large estimates that come from small sample sizes
#We use regularization to reduce the effect of bias because of extreme rating by the users on movies as users prefer movies over others ,,,
# we use lambda to denote the prediction obtained when we use a parameter  ,, we use this formula 
$$\hat{b_{i}} (\lambda) = \frac{1}{\lambda + n_{i}} \sum_{u=1}^{n_{i}} (Y_{u,i} - \hat{\mu}) $$  



#The next working steps 
#compute regularized movie bias term
# compute regularize movie and user bias term
# compute regularize movie and user and genres bias term
# compute predictions on validation set
# return RMSE of the predictions

```{r model, echo=TRUE}
# first we determine a sequence (lambda)
lambda <- seq(from=0, to=10, by=0.1)

# output RMSE of each lambda
rmses <- sapply(lambda, function(l){
# calculate average 
mu <- mean(edx$rating)
 
# compute regularized movie bias part
  movie_avg <- edx %>% 
  group_by(movieId) %>%
  summarize(movie_bias = sum(rating - mu)/(n()+l))
  
# Compute the predicted ratings on validation dataset
  predict_rate <- validation %>%
  left_join(movie_bias, by='movieId') %>%
  mutate(pred = mu + movie_bias) %>%
  pull(pred)

  return(RMSE(predict_rate, validation$rating))
})


```

## Including Plots

```{r Lambdas vs RMSEs, echo=FALSE}
#qplot(lambda, rmses)

# plot lambda's results

dframe <- data.frame(RMSE = rmses, lambdas = lambda)

ggplot(dframe, aes(lambda, rmses)) +
   theme_light() +
   geom_point() +
   labs(title = "Lambdas vs RMSEs / Regularized Movie bias Term",
        y = "RMSEs",
        x = "lambdas")

```


```{r model, echo=TRUE}
# find lambda value that minimize the RMSE
min_lambda <- lambda[which.min(rmses)]

min_lambda

# Predict the RMSE on the validation set

rmse_regularizedmovieterm <- min(rmses)
rmse_regularizedmovieterm

# Adding the results to the results dataset
results <- results %>% add_row(model="Regularized Movie Term", RMSE=rmse_regularizedmovieterm)

```

```{r regularized movies and user term, echo=TRUE}
#lamd <-lambda[which.min(rmses)]

# Since we see before that the movie and user bias model had the acceptable RMSE ,, we will ses if the regularization technique will improve the RMSE in movies and user term

# Determine a sequence (lambda)
lambda <- seq(from=0, to=10, by=0.1)


# output RMSE of each lambda
rmses <- sapply(lambda, function(l){

# calculate average 
mu <- mean(edx$rating)

movie_avg <- edx %>% 
  group_by(movieId) %>%
  summarize(movie_bias = sum(rating - mu)/(n()+l))

user_avg <- edx %>% 
  left_join(movie_bias, by="movieId") %>%
  group_by(userId) %>%
  summarize(user_bias = sum(rating - movie_bias - mu)/(n()+l))
 
predict_rat <- validation %>% 
  left_join(movie_bias, by = "movieId") %>%
  left_join(user_bias, by = "userId") %>%
  mutate(pred = mu + movie_bias + user_bias) %>%
  pull(pred)

RMSE(predict_rat, validation$rating)
})
```


# Now we plot the Lambdas vs RMSEs for the Regularized Movie and user bias Term
```{r Lambdas vs RMSEs, echo=FALSE}
#qplot(lambda, rmses)

# plot lambda's results

dframe <- data.frame(RMSE = rmses, lambdas = lambda)

ggplot(dframe, aes(lambda, rmses)) +
   theme_light() +
   geom_point() +
   labs(title = "Lambdas vs RMSEs / Regularized Movie and User bias Term",
        y = "RMSEs",
        x = "lambdas")

```

# find lambda value that minimize the RMSE in Regularized Movie and User bias Term

```{r model, echo=TRUE}
# find lambda value that minimize the RMSE in Regularized Movie and User bias Term
min_lambda <- lambda[which.min(rmses)]

min_lambda

# Predict the RMSE on the validation set

rmse_regularizedmovieuserterm <- min(rmses)
rmse_regularizedmovieuserterm

# Adding the results to the results dataset
results <- results %>% add_row(model="Regularized Movie and User Term", RMSE=rmse_regularizedmovieuserterm)

```

#We can see that the RMSE from regularized movies and user term is Slightly lower than the non regularized movies and user bias term ,, let us see if can had a better performance  
#Let us compute the Regularized movie and user and genres Term and see if it would make RMSE is less than before

```{r regularized movies and user and genres term, echo=TRUE}

# Determine a sequence (lambda)
lambda <- seq(from=0, to=10, by=0.1)


# output RMSE of each lambda
rmses <- sapply(lambda, function(l){
# calculate average 
mu <- mean(edx$rating)
  
movie_avg <- edx %>% 
  group_by(movieId) %>%
  summarize(movie_bias = sum(rating - mu)/(n()+l))

user_avg <- edx %>% 
  left_join(movie_bias, by="movieId") %>%
  group_by(userId) %>%
  summarize(user_bias = sum(rating - movie_bias - mu)/(n()+l))
 
prefered_genre <- edx %>%
      left_join(movie_avg, by='movieId') %>%
      left_join(user_avg, by='userId') %>%
      group_by(genres) %>%
      summarize(mov_user_gen= sum(rating - mu - movie_bias - user_bias) / (n() + l))


predict_rat <- validation %>% 
  left_join(movie_avg, by = "movieId") %>%
  left_join(user_avg, by = "userId") %>%
  left_join( prefered_genre, by="genres") %>%
  mutate(pred = mu + movie_bias + user_bias + mov_user_gen) %>%
  pull(pred)

RMSE(predict_rat, validation$rating)
})
```


# Now we plot the Lambdas vs RMSEs for the Regularized Movie and user and genres bias Term
```{r Lambdas vs RMSEs, echo=FALSE}
#qplot(lambda, rmses)

# plot lambda's results

dframe <- data.frame(RMSE = rmses, lambdas = lambda)

ggplot(dframe, aes(lambda, rmses)) +
   theme_light() +
   geom_point() +
   labs(title = "Lambdas vs RMSEs / Regularized Movie and User and Genres bias Term",
        y = "RMSEs",
        x = "lambdas")

```

# find lambda value that minimize the RMSE in Regularized Movie and User and Genres bias Term

```{r model, echo=TRUE}
# find lambda value that minimize the RMSE in Regularized Movie and User and Genres bias Term
min_lambda <- lambda[which.min(rmses)]

min_lambda

# Predict the RMSE on the validation set

rmse_regularizedmovieuserterm <- min(rmses)
rmse_regularizedmovieuserterm

# Adding the results to the results dataset
results <- results %>% add_row(model="Regularized Movie and User and Genres Term", RMSE=rmse_regularizedmovieuserterm)

```

## Results and conclusions:

## As a conclusion we find that The linear model is effective way to make prediction on movie ratings as well RMSE had been minimized since we regularized the biased model,, 
#so after training different models, we find out that movie_id  and user_id gives a desireable value of RMSE Without regularization, but the best model when applying regularization and adding the genres predictor, it make possible to reach the lowest RSME which is the best result for the trained models.

